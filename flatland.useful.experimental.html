<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>flatland.useful.experimental documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Useful 0.11.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>flatland</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>useful</span></div></div></li><li class="depth-3 branch"><a href="flatland.useful.bean.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bean</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.cli.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cli</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.compress.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compress</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.datatypes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatypes</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.debug.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debug</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.deftype.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deftype</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.dispatch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dispatch</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3 current"><a href="flatland.useful.experimental.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>experimental</span></div></a></li><li class="depth-4 branch"><a href="flatland.useful.experimental.delegate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>delegate</span></div></a></li><li class="depth-4"><a href="flatland.useful.experimental.unicode.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>unicode</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.fn.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>fn</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.java.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>java</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.macro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macro</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.parallel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parallel</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.seq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>seq</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-3"><a href="flatland.useful.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="flatland.useful.experimental.html#var-comp-partial"><div class="inner"><span>comp-partial</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-cond-let"><div class="inner"><span>cond-let</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-defn-wrapping"><div class="inner"><span>defn-wrapping</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-fixes"><div class="inner"><span>fixes</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-let-if"><div class="inner"><span>let-if</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-lift-meta"><div class="inner"><span>lift-meta</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-make-wrappable.21"><div class="inner"><span>make-wrappable!</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-order-let-if"><div class="inner"><span>order-let-if</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-prefix-lookup"><div class="inner"><span>prefix-lookup</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-protocol-stub"><div class="inner"><span>protocol-stub</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-while-let"><div class="inner"><span>while-let</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-with-wrapper"><div class="inner"><span>with-wrapper</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-with-wrappers"><div class="inner"><span>with-wrappers</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-wrap-multiple"><div class="inner"><span>wrap-multiple</span></div></a></li><li class="depth-1"><a href="flatland.useful.experimental.html#var-wrap-with"><div class="inner"><span>wrap-with</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">flatland.useful.experimental</h2><pre class="doc"></pre><div class="public anchor" id="var-comp-partial"><h3>comp-partial</h3><div class="usage"><code>(comp-partial n &amp; fns)</code></div><pre class="doc">A version of comp that &quot;rescues&quot; the first N args, passing them to every composed function
instead of just the first one.

For example, ((comp-partial 2 * +) 3 4 5 6) is equivalent to (* 3 4 (+ 3 4 5 6)).</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L8">view source</a></div></div><div class="public anchor" id="var-cond-let"><h3>cond-let</h3><h4 class="type">macro</h4><div class="usage"><code>(cond-let test-binding then-form &amp; more)</code></div><pre class="doc">An implementation of cond-let that is as similar as possible to if-let. Takes multiple
test-binding/then-form pairs and evalutes the form if the binding is true. Also supports
:else in the place of test-binding and always evaluates the form in that case.

Example:
 (cond-let [b (bar 1 2 3)] (println :bar b)
           [f (foo 3 4 5)] (println :foo f)
           [b (baz 6 7 8)] (println :baz b)
           :else           (println :no-luck))</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L31">view source</a></div></div><div class="public anchor" id="var-defn-wrapping"><h3>defn-wrapping</h3><h4 class="type">macro</h4><div class="usage"><code>(defn-wrapping name wrappers-var &amp; defn-args)</code></div><pre class="doc">Define a function as with defn, which checks the contents of wrappers-var
whenever it is called. If that var is empty, the underlying defn is called
without modification. Otherwise, it is treated as a list of wrapper functions,
which are wrapped around the underlying implementation before it is called.

The wrappers are applied left-to-right, which means that the rightmost
wrapper is outermost, and the leftmost wrapper is applied just before the base
function.

The wrappers are not called &quot;directly&quot; on the arguments, but are
instead called like Ring wrappers, to create a single function composed of
all of them; the resulting function is called with the actual arguments to
the defn-wrapping function.

For example, if the wrapped function is -, and the wrappers are
[(fn [f] (fn [x] (* 2 (f x)))), (fn [f] (fn [x] (f (+ 10 x))))],
then the eventual function will behave like (fn [x] (* 2 (- (+ 10 x)))).

Swapping the order of the wrappers would yield a function behaving like
(fn [x] (* 2 (+ 10 (- x)))).

Note the order of the wrapping: when called with 10 as an argument, the former
will return -40, and the latter 0.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L174">view source</a></div></div><div class="public anchor" id="var-fixes"><h3>fixes</h3><div class="usage"><code>(fixes x &amp; clauses)</code></div><pre class="doc">Like fix, but each clause is tested whether or not the previous clauses matched, so multiple
transformations may be applied. Unlike fix, fixes does not support a final one-element &quot;pair&quot;.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L218">view source</a></div></div><div class="public anchor" id="var-let-if"><h3>let-if</h3><h4 class="type">macro</h4><div class="usage"><code>(let-if test bindings &amp; forms)</code></div><pre class="doc">Choose a set of bindings based on the result of a conditional test.

Example:
 (let-if (even? a)
         [b (bar 1 2 3) (baz 1 2 3)
          c (foo 1)     (foo 3)]
   (println (combine b c)))</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L48">view source</a></div></div><div class="public anchor" id="var-lift-meta"><h3>lift-meta</h3><div class="usage"><code>(lift-meta m &amp; ks)</code></div><pre class="doc">Move some of the keys from m into its metadata, overriding existing values.
(lift-meta {:a 1 :b 2} [:a]) -&gt; ^{:a 1} {:b 2]</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L231">view source</a></div></div><div class="public anchor" id="var-make-wrappable.21"><h3>make-wrappable!</h3><div class="usage"><code>(make-wrappable! fn-var wrappers-var &amp; [name])</code></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L166">view source</a></div></div><div class="public anchor" id="var-order-let-if"><h3>order-let-if</h3><h4 class="type">macro</h4><div class="usage"><code>(order-let-if pred bindings &amp; body)</code></div><pre class="doc">If predicate is true, bind the names provided, otherwise reverse those bindings.

Example:
 (order-let-if false [a &quot;foo&quot; b &quot;bar&quot;] [a b]) = [&quot;bar&quot; &quot;foo&quot;]</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L62">view source</a></div></div><div class="public anchor" id="var-prefix-lookup"><h3>prefix-lookup</h3><div class="usage"><code>(prefix-lookup prefix-map)</code></div><pre class="doc">Takes a map whose keys are names, and returns a function that does fast prefix
matching on its input against the names in the original map, returning the
first value whose key is a prefix.

If order is important (eg because your prefixes overlap, or you want to test
common prefixes first for performance), you can pass a sequence of pairs
instead of a map.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L238">view source</a></div></div><div class="public anchor" id="var-protocol-stub"><h3>protocol-stub</h3><h4 class="type">macro</h4><div class="usage"><code>(protocol-stub name proto-specs)</code></div><pre class="doc">Define a new type of record implementing the specified protocols. Its
constructor will take two arguments:
  - An object which already satisfies the given protocols. This object will
    be delegated to for functions which are not stubbed out.
  - A &quot;log&quot; function to be called (for side effects) every time a protocol
    function is called. For functions marked as :stub (see below), the
    log function will be called with two arguments: the function name (an
    unqualified symbol), and the arglist (including &quot;this&quot;). Functions
    marked :forward will have a third argument, the function&apos;s return value.
    Use this function to implement your logging (or whatever else).

The macro itself needs two arguments: the name of the record to define, and:
  - A map of protocol stubbing specifications. Each key should be a protocol,
    and the value another map. It may have zero or more of these keys:
    - A :default key specifying either :stub or :forward, to control whether
      the underlying implementation is called after logging. Defaults to :stub,
      meaning that only the logging function will be called, completely
      stubbing out the backing implementation.
    - An :exceptions key, listing the functions of this protocol that should
      behave the opposite of the :default.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L96">view source</a></div></div><div class="public anchor" id="var-while-let"><h3>while-let</h3><h4 class="type">macro</h4><div class="usage"><code>(while-let bindings &amp; body)</code></div><pre class="doc">Repeatedly executes body, which presumably has side-effects, while let binding is not false.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L22">view source</a></div></div><div class="public anchor" id="var-with-wrapper"><h3>with-wrapper</h3><h4 class="type">macro</h4><div class="usage"><code>(with-wrapper wrappers-var wrap-fn &amp; body)</code></div><pre class="doc">Dynamically bind an additional wrapper to the specified wrapper-var
(see defn-wrapping). The wrapper function will be conj-ed onto the current
set of wrappers.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L211">view source</a></div></div><div class="public anchor" id="var-with-wrappers"><h3>with-wrappers</h3><h4 class="type">macro</h4><div class="usage"><code>(with-wrappers wrappers-var wrap-fns &amp; body)</code></div><pre class="doc">Dynamically bind some additional wrappers to the specified wrapper-var
(see defn-wrapping). Each wrapper function will be conj-ed onto the current
set of wrappers.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L203">view source</a></div></div><div class="public anchor" id="var-wrap-multiple"><h3>wrap-multiple</h3><h4 class="type">macro</h4><div class="usage"><code>(wrap-multiple wrappers-var &amp; fn-syms)</code></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L169">view source</a></div></div><div class="public anchor" id="var-wrap-with"><h3>wrap-with</h3><div class="usage"><code>(wrap-with f wrapper-var &amp; [name])</code></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/experimental.clj#L149">view source</a></div></div></div></body></html>