<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>flatland.useful.seq documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Useful 0.11.5 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>flatland</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>useful</span></div></div></li><li class="depth-3 branch"><a href="flatland.useful.bean.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bean</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.cli.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cli</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.compress.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compress</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.datatypes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatypes</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.debug.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debug</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.deftype.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deftype</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.destructure.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>destructure</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.dispatch.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dispatch</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3"><a href="flatland.useful.experimental.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>experimental</span></div></a></li><li class="depth-4 branch"><a href="flatland.useful.experimental.delegate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>delegate</span></div></a></li><li class="depth-4"><a href="flatland.useful.experimental.unicode.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>unicode</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.fn.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>fn</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.java.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>java</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.macro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macro</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.parallel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parallel</span></div></a></li><li class="depth-3 branch current"><a href="flatland.useful.seq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>seq</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-3 branch"><a href="flatland.useful.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-3"><a href="flatland.useful.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="flatland.useful.seq.html#var-alternates"><div class="inner"><span>alternates</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-assert-length"><div class="inner"><span>assert-length</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-cross"><div class="inner"><span>cross</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-extract"><div class="inner"><span>extract</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-find-first"><div class="inner"><span>find-first</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-find-with"><div class="inner"><span>find-with</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-flatten-all"><div class="inner"><span>flatten-all</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-foldr"><div class="inner"><span>foldr</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-glue"><div class="inner"><span>glue</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-groupings"><div class="inner"><span>groupings</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-include.3F"><div class="inner"><span>include?</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-increasing"><div class="inner"><span>increasing</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-increasing*"><div class="inner"><span>increasing*</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-indexed"><div class="inner"><span>indexed</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-insert"><div class="inner"><span>insert</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-lazy"><div class="inner"><span>lazy</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-lazy-cross"><div class="inner"><span>lazy-cross</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-lazy-loop"><div class="inner"><span>lazy-loop</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-map-nth"><div class="inner"><span>map-nth</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-merge-sorted"><div class="inner"><span>merge-sorted</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-partition-between"><div class="inner"><span>partition-between</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-prefix-of.3F"><div class="inner"><span>prefix-of?</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-remove-prefix"><div class="inner"><span>remove-prefix</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-separate"><div class="inner"><span>separate</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-seque*"><div class="inner"><span>seque*</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-sequeue"><div class="inner"><span>sequeue</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-single.3F"><div class="inner"><span>single?</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-slice"><div class="inner"><span>slice</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-take-shuffled"><div class="inner"><span>take-shuffled</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-take-until"><div class="inner"><span>take-until</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-unchunk"><div class="inner"><span>unchunk</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-unfold"><div class="inner"><span>unfold</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-update-first"><div class="inner"><span>update-first</span></div></a></li><li class="depth-1"><a href="flatland.useful.seq.html#var-zip"><div class="inner"><span>zip</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">flatland.useful.seq</h2><pre class="doc"></pre><div class="public anchor" id="var-alternates"><h3>alternates</h3><div class="usage"><code>(alternates coll)</code><code>(alternates threads coll)</code></div><pre class="doc">Split coll into &apos;threads&apos; subsequences (defaults to 2), feeding
each alternately from the input sequence. Effectively the inverse of
interleave:

(alternates 3 (range 9))
;=&gt; ((0 3 6) (1 4 7) (2 5 8))</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L95">view source</a></div></div><div class="public anchor" id="var-assert-length"><h3>assert-length</h3><div class="usage"><code>(assert-length len coll)</code></div><pre class="doc">Assert, as a side effect, that coll has exactly len elements, and then
return coll.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L405">view source</a></div></div><div class="public anchor" id="var-cross"><h3>cross</h3><div class="usage"><code>(cross &amp; seqs)</code></div><pre class="doc">Computes the cartesian-product of the provided seqs. In other words, compute the set of all
possible combinations of ways you can choose one item from each seq.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L63">view source</a></div></div><div class="public anchor" id="var-extract"><h3>extract</h3><div class="usage"><code>(extract pred coll)</code></div><pre class="doc">Extracts the first item that matches pred from coll, returning a vector of that item
followed by coll with the item removed.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L19">view source</a></div></div><div class="public anchor" id="var-find-first"><h3>find-first</h3><div class="usage"><code>(find-first pred coll)</code></div><pre class="doc">Returns the first item of coll where (pred item) returns logical true.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L7">view source</a></div></div><div class="public anchor" id="var-find-with"><h3>find-with</h3><div class="usage"><code>(find-with pred keys vals)</code></div><pre class="doc">Returns the val corresponding to the first key where (pred key) returns true.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L12">view source</a></div></div><div class="public anchor" id="var-flatten-all"><h3>flatten-all</h3><div class="usage"><code>(flatten-all form)</code></div><pre class="doc">Takes a nested collection and flattens it into one flat collection.
Like clojure.core/flatten, but also works with maps and collections
containing nested maps.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L416">view source</a></div></div><div class="public anchor" id="var-foldr"><h3>foldr</h3><div class="usage"><code>(foldr f start coll)</code></div><pre class="doc"><a href="http://www.haskell.org/haskellwiki/Fold">http://www.haskell.org/haskellwiki/Fold</a>
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L173">view source</a></div></div><div class="public anchor" id="var-glue"><h3>glue</h3><div class="usage"><code>(glue combine glue? coll)</code><code>(glue combine init glue? coll)</code><code>(glue combine init glue? unglue? coll)</code></div><pre class="doc">Walk over an input sequence, &quot;gluing&quot; together elements to create batches.
Batches may be of any type you like, and are computed as follows:
- Each batch is initialized by combining init (default false) with next-item.
- For each additional item in coll, functions glue? and unglue? are consulted to
  decide whether the next item should be included into the current batch.
  - If (glue? current-batch next-item) returns truthy, then a prospective
    updated-batch is computed, as (combine current-batch next-item). If
    (unglue? updated-batch) returns falsey, then updated-batch is accepted and
    may be used as the target for further gluing.
  - If glue? returned falsey, or unglue? returned truthy, then the current batch
    is inserted into the output sequence, and a new batch is started as
    (combine init next-item).</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L193">view source</a></div></div><div class="public anchor" id="var-groupings"><h3>groupings</h3><div class="usage"><code>(groupings group transform coll)</code><code>(groupings group reductor init coll)</code></div><pre class="doc">Similar to clojure.core/group-by, but allowing you to specify how to add items to each group.
For example, if you are grouping by :name, you may want to remove the :name key from each map
before adding it to the list. So, you can specify #(dissoc % :name) as your transform.

If you need finer-grained control, you can specify a reduce function for accumulating each group,
rather than mapping over the items in it. For example, (groupings even? + 0 coll) finds you the
sum of all odd numbers in coll and the sum of all even numbers in coll.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L422">view source</a></div></div><div class="public anchor" id="var-include.3F"><h3>include?</h3><div class="usage"><code>(include? val coll)</code></div><pre class="doc">Check if val exists in coll.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L34">view source</a></div></div><div class="public anchor" id="var-increasing"><h3>increasing</h3><div class="usage"><code>(increasing coll)</code><code>(increasing keyfn coll)</code><code>(increasing keyfn comp coll)</code></div><pre class="doc">Throw away any elements from coll which are not in increasing order, according to keyfn and
comp (used similarly to the arguments to sort-by).</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L458">view source</a></div></div><div class="public anchor" id="var-increasing*"><h3>increasing*</h3><div class="usage"><code>(increasing* keyfn comp coll)</code></div><pre class="doc">Scans through a collection, comparing items via (comp (keyfn x) (keyfn y)), and finding those
which are in increasing order. Each input item x is output once, as part of a pair, [included?
x]. Those items which are part of an increasing sequence will have included? true, while any that
go &quot;backwards&quot; from the current max will have included? false.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L441">view source</a></div></div><div class="public anchor" id="var-indexed"><h3>indexed</h3><div class="usage"><code>(indexed coll)</code></div><pre class="doc">Returns a lazy sequence of pairs of index and item.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L284">view source</a></div></div><div class="public anchor" id="var-insert"><h3>insert</h3><div class="usage"><code>(insert items n coll)</code></div><pre class="doc">Inserts a seq of items into coll at position n.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L48">view source</a></div></div><div class="public anchor" id="var-lazy"><h3>lazy</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy &amp; exprs)</code></div><pre class="doc">Return a lazy sequence of the passed-in expressions. Each will be evaluated
only if necessary.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L186">view source</a></div></div><div class="public anchor" id="var-lazy-cross"><h3>lazy-cross</h3><div class="usage"><code>(lazy-cross &amp; seqs)</code></div><pre class="doc">Compute a lazy cartesian-product of the provided seqs. The provided seqs can be lazy or even
infinite, and lazy-cross will consume all sequences equally, only consuming more of any sequence
when all possible combinations at the current level have been exhausted. This can be thought of
intuitively as a breadth-first search of the cartesian product set.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L73">view source</a></div></div><div class="public anchor" id="var-lazy-loop"><h3>lazy-loop</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-loop bindings &amp; body)</code></div><pre class="doc">Provide a simplified version of lazy-seq to eliminate
boilerplate. Arguments are as to the built-in (loop...recur),
and (lazy-recur) will be defined for you. However, instead of doing
actual tail recursion, lazy-recur trampolines through lazy-seq. In
addition to enabling laziness, this means you can call lazy-recur
when not in the tail position.

Regular recurs are also supported, if they are in tail position and don&apos;t
need any laziness.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L108">view source</a></div></div><div class="public anchor" id="var-map-nth"><h3>map-nth</h3><div class="usage"><code>(map-nth f nth coll)</code><code>(map-nth f start nth coll)</code></div><pre class="doc">Calls f on every nth element of coll. If start is passed, starts
at that element (counting from zero), otherwise starts with zero.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L374">view source</a></div></div><div class="public anchor" id="var-merge-sorted"><h3>merge-sorted</h3><div class="usage"><code>(merge-sorted comparator)</code><code>(merge-sorted comparator xs)</code><code>(merge-sorted comparator xs ys)</code><code>(merge-sorted comparator xs ys &amp; more)</code></div><pre class="doc">Merge N sorted sequences together, as in the merge phase of a merge-sort.
Comparator should be a two-argument predicate like `&lt;`, which returns true if
its first argument belongs before its second element in the merged sequence.
The collections themselves should already be sorted in the order your
comparator would put them; otherwise ordering is undefined.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L259">view source</a></div></div><div class="public anchor" id="var-partition-between"><h3>partition-between</h3><div class="usage"><code>(partition-between split? coll)</code></div><pre class="doc">Partition an input seq into multiple sequences, as with partition-by.
Walks the collection two at a time, calling (split? [a b]) for each pair.
Any time split? returns truthy, the partition containing a ends, and a new
one containing b begins. Note that the split? predicate should not take two
arguments, but instead a single argument, a pair.

Like partition-by, a lazy sequence of partitions is returned, but the
partitions themselves are eager.

For example, to cause each nil to be folded into the next partition:
(partition-between (fn [[a b]] (not (nil? a))) &apos;[1 nil nil 2 nil 3])
=&gt; ([1] [nil nil 2] [nil 3])</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L224">view source</a></div></div><div class="public anchor" id="var-prefix-of.3F"><h3>prefix-of?</h3><div class="usage"><code>(prefix-of? coll prefix)</code></div><pre class="doc">Given prefix is N elements long, are the first N elements of coll equal to prefix?
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L254">view source</a></div></div><div class="public anchor" id="var-remove-prefix"><h3>remove-prefix</h3><div class="usage"><code>(remove-prefix prefix coll)</code></div><pre class="doc">Remove prefix from coll, returning the remaining suffix. Returns nil if prefix does not
match coll.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L244">view source</a></div></div><div class="public anchor" id="var-separate"><h3>separate</h3><div class="usage"><code>(separate pred coll)</code></div><pre class="doc">Split coll into two sequences, one that matches pred and one that doesn&apos;t. Unlike the
version in clojure.contrib.seq-utils, pred is only called once per item.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L26">view source</a></div></div><div class="public anchor" id="var-seque*"><h3>seque*</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(seque* s)</code><code>(seque* n-or-q s)</code></div><pre class="doc">A version of clojure.core/seque that fixes a memory/thread-handle leak.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L325">view source</a></div></div><div class="public anchor" id="var-sequeue"><h3>sequeue</h3><div class="usage"><code>(sequeue s)</code><code>(sequeue n-or-q s)</code></div><pre class="doc">A version of seque from clojure.core that uses a future instead of an agent.
The agent version was causing problems because you can&apos;t depend on an agent from
within another agent&apos;s action, which means you can&apos;t use seque inside an agent.

This version is probably less performant, because it keeps a thread running
until the sequence is entirely consumed, and it attempts to refill the queue as
soon as there is space, rather than when the queue is emptied.

More importantly, though, this version may be *DANGEROUS* if you are not careful:
if you do not consume the entire output sequence, the future-thread will remain
active indefinitely, blocking on the queue and holding the lazy sequence open,
ineligible for garbage collection.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L289">view source</a></div></div><div class="public anchor" id="var-single.3F"><h3>single?</h3><div class="usage"><code>(single? coll)</code></div><pre class="doc">Does coll have only one element?
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L399">view source</a></div></div><div class="public anchor" id="var-slice"><h3>slice</h3><div class="usage"><code>(slice n coll)</code></div><pre class="doc">Divide coll into n approximately equal slices.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L54">view source</a></div></div><div class="public anchor" id="var-take-shuffled"><h3>take-shuffled</h3><div class="usage"><code>(take-shuffled n coll)</code></div><pre class="doc">Lazily take (at most) n elements at random from coll, without
replacement. For n=1, this is equivalent to rand-nth; for n&gt;=(count
coll) it is equivalent to shuffle.

Clarification of &quot;without replacement&quot;: each index in the original
collection is chosen at most once. Thus if the original collection
contains no duplicates, neither will the result of this
function. But if the original collection contains duplicates, this
function may include them in its output: it does not do any
uniqueness checking aside from being careful not to use the same
index twice.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L149">view source</a></div></div><div class="public anchor" id="var-take-until"><h3>take-until</h3><div class="usage"><code>(take-until pred coll)</code></div><pre class="doc">Take from coll up to and including the first item that satisfies pred.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L365">view source</a></div></div><div class="public anchor" id="var-unchunk"><h3>unchunk</h3><div class="usage"><code>(unchunk s)</code></div><pre class="doc">Create a one-at-a-time sequence out of a chunked sequence.
</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L178">view source</a></div></div><div class="public anchor" id="var-unfold"><h3>unfold</h3><div class="usage"><code>(unfold next seed)</code></div><pre class="doc">Traditionally unfold is the &apos;opposite of reduce&apos;: it turns a single
seed value into a (possibly infinite) lazy sequence of output
values.

Next is a function that operates on a seed: it should
return a pair, [value new-seed]; the value half of the pair is
inserted into the resulting list, while the new seed is used to
continue unfolding. Notably, the value is never passed as an
argument to next. If nil is returned instead of a pair, the resulting
sequence will terminate.

(defn fibs []
  (unfold (fn [[a b]]
            [a [b (+ a b)]])
          [0 1]))</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L128">view source</a></div></div><div class="public anchor" id="var-update-first"><h3>update-first</h3><div class="usage"><code>(update-first coll pred f)</code><code>(update-first coll pred f &amp; args)</code></div><pre class="doc">Returns a lazy-seq that is a version of coll with the first item matching
pred updated by calling f on it with the supplied args.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L384">view source</a></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; colls)</code></div><pre class="doc">Returns a lazy sequence of vectors of corresponding items from each collection. If one collection
is longer than the others, the missing items will be filled in with nils.</pre><div class="src-link"><a href="http://github.com/flatland/useful/blob/develop/src/flatland/useful/seq.clj#L39">view source</a></div></div></div></body></html>